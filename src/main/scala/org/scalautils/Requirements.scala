/*
 * Copyright 2001-2012 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.scalautils

import reflect.macros.Context

trait Requirements {

  import language.experimental.macros

  /**
   * Helper class used by code generated by the <code>require</code> macro.
   */
  class RequirementsHelper {

    private def append(currentMessage: String, clueOpt: Option[Any]): String =
      clueOpt match {
        case Some(clue) =>
          val firstChar = clue.toString.head
          if (firstChar.isWhitespace || firstChar == '.' || firstChar == ',' || firstChar == ';')
            currentMessage + clue.toString
          else
            currentMessage + " " + clue.toString
        case None => currentMessage
      }

    def getObjectsForFailureMessage(a: Any, b: Any) =
      a match {
        case aEqualizer: org.scalautils.TripleEqualsSupport#Equalizer[_] =>
          Prettifier.getObjectsForFailureMessage(aEqualizer.leftSide, b)
        case aEqualizer: org.scalautils.TripleEqualsSupport#CheckingEqualizer[_] =>
          Prettifier.getObjectsForFailureMessage(aEqualizer.leftSide, b)
        case _ => Prettifier.getObjectsForFailureMessage(a, b)
      }

    /**
     * Require that the passed in expression is <code>true</code>, else fail with <code>IllegalArgumentException</code>.
     *
     * @param expression <code>Boolean</code> expression to check as requirement
     * @param clue optional clue to be included in <code>IllegalArgumentException</code>'s error message when the requirement failed
     */
    def macroRequire(expression: Boolean, clue: Option[Any]) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!expression)
        throw new IllegalArgumentException(if (clue.isDefined) clue.get + "" else FailureMessages("expressionWasFalse"))
    }

    /**
     * Require that the passed in expression is <code>true</code>, else fail with <code>IllegalArgumentException</code>.
     *
     * @param left the LHS of the expression
     * @param operator the operator of the expression
     * @param right the RHS of the expression
     * @param expression <code>Boolean</code> expression to check as requirement
     * @param clue optional clue to be included in <code>IllegalArgumentException</code>'s error message when requirement failed
     */
    def macroRequire(left: Any, operator: String, right: Any, expression: Boolean, clue: Option[Any]) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!expression) {
        throw operator match {
          case "==" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("didNotEqual", leftee, rightee), clue))
          case "===" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("didNotEqual", leftee, rightee), clue))
          case "!=" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("equaled", leftee, rightee), clue))
          case "!==" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("equaled", leftee, rightee), clue))
          /*case ">" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotGreaterThan", left, right)), clue))
          case ">=" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotGreaterThanOrEqualTo", left, right)), clue))
          case "<" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotLessThan", left, right)), clue))
          case "<=" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotLessThanOrEqualTo", left, right)), clue))*/
          case _ =>
            throw new IllegalArgumentException(if (clue.isDefined) clue.get + "" else FailureMessages("expressionWasFalse"))
        }
      }
    }

    /**
     * Require that the passed in expression is <code>true</code>, else fail with <code>IllegalStateException</code>.
     *
     * @param expression <code>Boolean</code> expression to check as requirement
     * @param clue optional clue to be included in <code>IllegalStateException</code>'s error message when the requirement failed
     */
    def macroRequireState(expression: Boolean, clue: Option[Any]) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!expression)
        throw new IllegalStateException(if (clue.isDefined) clue.get + "" else FailureMessages("expressionWasFalse"))
    }

    /**
     * Require that the passed in expression is <code>true</code>, else fail with <code>IllegalStateException</code>.
     *
     * @param left the LHS of the expression
     * @param operator the operator of the expression
     * @param right the RHS of the expression
     * @param expression <code>Boolean</code> expression to check as requirement
     * @param clue optional clue to be included in <code>IllegalStateException</code>'s error message when requirement failed
     */
    def macroRequireState(left: Any, operator: String, right: Any, expression: Boolean, clue: Option[Any]) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!expression) {
        throw operator match {
          case "==" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalStateException(append(FailureMessages("didNotEqual", leftee, rightee), clue))
          case "===" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalStateException(append(FailureMessages("didNotEqual", leftee, rightee), clue))
          case "!=" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalStateException(append(FailureMessages("equaled", leftee, rightee), clue))
          case "!==" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalStateException(append(FailureMessages("equaled", leftee, rightee), clue))
          /*case ">" => throw new IllegalStateException(append(Some(FailureMessages("wasNotGreaterThan", left, right)), clue))
          case ">=" => throw new IllegalStateException(append(Some(FailureMessages("wasNotGreaterThanOrEqualTo", left, right)), clue))
          case "<" => throw new IllegalStateException(append(Some(FailureMessages("wasNotLessThan", left, right)), clue))
          case "<=" => throw new IllegalStateException(append(Some(FailureMessages("wasNotLessThanOrEqualTo", left, right)), clue))*/
          case _ =>
            throw new IllegalStateException(if (clue.isDefined) clue.get + "" else FailureMessages("expressionWasFalse"))
        }
      }
    }

    /**
     * Require that all of the passed in elements are not <code>null</code>, else fail with <code>NullPointerException</code>.
     *
     * @param variableNames names of variable passed as appear in source
     * @param elements elements to check for <code>null</code> value
     */
    def macroRequireNonNull(variableNames: Array[String], elements: Array[Any]) {
      val nullList = elements.zipWithIndex.filter { case (e, idx) =>
        e == null
      }
      val nullCount = nullList.size
      if (nullCount > 0) {
        val nullVariableNames = nullList.map { case (e, idx) =>
          variableNames(idx)
        }
        val errorMessage =
          if (nullCount == 1)
            FailureMessages("wasNull", UnquotedString(nullVariableNames(0)))
          else {
            val combinedVariableNames = Resources("and", nullVariableNames.dropRight(1).mkString(Resources("comma")), nullVariableNames.last)
            FailureMessages("wereNull", UnquotedString(combinedVariableNames))
          }
        throw new NullPointerException(errorMessage)
      }
    }

  }

  /**
   * Helper instance used by code generated by macro assertion.
   */
  val requirementsHelper = new RequirementsHelper

  /**
   * Require that a boolean condition is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalArgumentException</code>.
   *
   * <p>
   * This method is implemented in terms of a Scala macro that will generate a more helpful error message
   * for simple quality checks of this form:
   * </p>
   *
   * <ul>
   * <li>require(a == b)</li>
   * <li>require(a != b)</li>
   * <li>require(a === b)</li>
   * <li>require(a !== b)</li>
   * </ul>
   *
   * <p>
   * Any other form of expression will just get a plain-old <code>IllegalArgumentException</code> at this time. In the future,
   * we will enhance this macro to give helpful error messages in more situations. In ScalaTest 2.x, however, this behavior
   * was sufficient to allow the <code>===</code> that returns <code>Boolean</code>, not <code>Option[String]</code> to be
   * the default in tests. This makes <code>===</code> consistent between tests and production code. If you have pre-existing
   * code you wrote under ScalaTest 1.x, in which you are expecting<code>===</code> to return an <code>Option[String]</code>,
   * use can get that behavior back by mixing in trait <a href="LegacyTripleEquals.html"><code>LegacyTripleEquals</code></a>.
   * </p>
   *
   * @param condition the boolean condition to check as requirement
   * @throws IllegalArgumentException if the condition is <code>false</code>.
   */
  def require(condition: Boolean): Unit = macro RequirementsMacro.require

  /**
   * Require that a boolean condition, described in <code>String</code>
   * <code>message</code>, is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalArgumentException</code> with the
   * <code>String</code> obtained by invoking <code>toString</code> on the
   * specified <code>clue</code> as the exception's detail message.
   *
   * @param condition the boolean condition to check as requirement
   * @param clue An objects whose <code>toString</code> method returns a message to include in a failure report.
   * @throws IllegalArgumentException if the condition is <code>false</code>.
   * @throws NullPointerException if <code>message</code> is <code>null</code>.
   */
  def require(condition: Boolean, clue: Any): Unit = macro RequirementsMacro.requireWithClue

  /**
   * Require that a boolean condition is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalStateException</code>.
   *
   * <p>
   * This method is implemented in terms of a Scala macro that will generate a more helpful error message
   * for simple quality checks of this form:
   * </p>
   *
   * <ul>
   * <li>requireState(a == b)</li>
   * <li>requireState(a != b)</li>
   * <li>requireState(a === b)</li>
   * <li>requireState(a !== b)</li>
   * </ul>
   *
   * <p>
   * Any other form of expression will just get a plain-old <code>IllegalStateException</code> at this time. In the future,
   * we will enhance this macro to give helpful error messages in more situations. In ScalaTest 2.x, however, this behavior
   * was sufficient to allow the <code>===</code> that returns <code>Boolean</code>, not <code>Option[String]</code> to be
   * the default in tests. This makes <code>===</code> consistent between tests and production code. If you have pre-existing
   * code you wrote under ScalaTest 1.x, in which you are expecting<code>===</code> to return an <code>Option[String]</code>,
   * use can get that behavior back by mixing in trait <a href="LegacyTripleEquals.html"><code>LegacyTripleEquals</code></a>.
   * </p>
   *
   * @param condition the boolean condition to check as requirement
   * @throws IllegalStateException if the condition is <code>false</code>.
   */
  def requireState(condition: Boolean): Unit = macro RequirementsMacro.requireState

  /**
   * Require that a boolean condition, described in <code>String</code>
   * <code>message</code>, is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalStateException</code> with the
   * <code>String</code> obtained by invoking <code>toString</code> on the
   * specified <code>clue</code> as the exception's detail message.
   *
   * @param condition the boolean condition to check as requirement
   * @param clue An objects whose <code>toString</code> method returns a message to include in a failure report.
   * @throws IllegalStateException if the condition is <code>false</code>.
   * @throws NullPointerException if <code>message</code> is <code>null</code>.
   */
  def requireState(condition: Boolean, clue: Any): Unit = macro RequirementsMacro.requireStateWithClue

  /**
   * Require that all passed in elements to be non-null.
   * If none of the passed in elements is <code>null</code>, this method returns normally.
   * Else, it throws <code>NullPointerException</code> with error message that includes the name(s)
   * (as appeared in source) of the element(s) that holds <code>null</code> value.
   *
   * @param elements elements to check for <code>null</code> value
   * @throws NullPointerException if any of the passed in elements is <code>null</code>.
   */
  def requireNonNull(elements: Any*): Unit = macro RequirementsMacro.requireNonNull
}

/**
 * Macro implementation that provides rich error message for boolean expression requirements.
 */
private[scalautils] object RequirementsMacro {

  /**
   * Provides requirement implementation for <code>Requirements.require(booleanExpr: Boolean)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalArgumentException</code> with rich error message if requirement failed
   */
  def require(context: Context)(condition: context.Expr[Boolean]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacroCode(condition, "macroRequire", None)

  /**
   * Provides requirement implementation for <code>Requirements.require(booleanExpr: Boolean, clue: Any)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @param clue original clue expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalArgumentException</code> with rich error message (clue included) if requirement failed
   */
  def requireWithClue(context: Context)(condition: context.Expr[Boolean], clue: context.Expr[Any]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacroCode(condition, "macroRequire", Some(clue.tree))

  /**
   * Provides requirement implementation for <code>Requirements.requireState(booleanExpr: Boolean)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalStateException</code> with rich error message if requirement failed
   */
  def requireState(context: Context)(condition: context.Expr[Boolean]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacroCode(condition, "macroRequireState", None)

  /**
   * Provides requirement implementation for <code>Requirements.requireState(booleanExpr: Boolean, clue: Any)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @param clue original clue expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalStateException</code> with rich error message (clue included) if requirement failed
   */
  def requireStateWithClue(context: Context)(condition: context.Expr[Boolean], clue: context.Expr[Any]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacroCode(condition, "macroRequireState", Some(clue.tree))

  /**
   * Provides requirement implementation for <code>Requirements.requireNonNull(elements: Any*)</code>, with rich error message.
   *
   * @param context macro context
   * @param elements original elements expression(s)
   * @return transformed expression that performs the requirement check and throw <code>NullPointerException</code> with rich error message if requirement failed
   */
  def requireNonNull(context: Context)(elements: context.Expr[Any]*): context.Expr[Unit] = {
    import context.universe._

    val variablesNamesArray =
      Apply(
        Select(
          Ident("Array"),
          newTermName("apply")
        ),
        List(elements.map(e => context.literal(show(e.tree)).tree): _*)
      )

    val elementsArray =
      Apply(
        Select(
          Ident("Array"),
          newTermName("apply")
        ),
        List(elements.map(e => e.tree): _*)
      )

    context.Expr(
      Apply(
        Select(
          Ident("requirementsHelper"),
          newTermName("macroRequireNonNull")
        ),
        List(variablesNamesArray, elementsArray)
      )
    )
  }
}