/*
 * Copyright 2001-2012 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.scalautils

import reflect.macros.Context

/**
 * Trait that contains <code>require</code> and <code>requireState</code> to check for requirements.
 */
trait Requirements {

  import language.experimental.macros

  /**
   * Helper class used by code generated by the <code>require</code> macro.
   */
  class RequirementsHelper {

    private def append(currentMessage: String, clue: Any): String = {
      val clueStr = clue.toString
      if (clueStr.isEmpty)
        currentMessage
      else {
        val firstChar = clueStr.head
        if (firstChar.isWhitespace || firstChar == '.' || firstChar == ',' || firstChar == ';' || currentMessage.isEmpty)
          currentMessage + clueStr
        else
          currentMessage + " " + clueStr
      }
    }

    /**
     * Require that the passed in <code>Bool</code> is <code>true</code>, else fail with <code>IllegalArgumentException</code>.
     *
     * @param bool the <code>Bool</code> to check as requirement
     * @param clue optional clue to be included in <code>IllegalArgumentException</code>'s error message when the requirement failed
     */
    def macroRequire(bool: Bool, clue: Any) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!bool.value) {
        val failureMessage = if (Bool.isSimpleWithoutExpressionText(bool)) append("", clue) else append(bool.failureMessage, clue)
        throw new IllegalArgumentException(if (failureMessage.isEmpty) FailureMessages("expressionWasFalse") else failureMessage)
      }
    }

    /**
     * Require that the passed in <code>Bool</code> is <code>true</code>, else fail with <code>IllegalStateException</code>.
     *
     * @param bool the <code>Bool</code> to check as requirement
     * @param clue optional clue to be included in <code>IllegalStateException</code>'s error message when the requirement failed
     */
    def macroRequireState(bool: Bool, clue: Any) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!bool.value) {
        val failureMessage = if (Bool.isSimpleWithoutExpressionText(bool)) append("", clue) else append(bool.failureMessage, clue)
        throw new IllegalStateException(if (failureMessage.isEmpty) FailureMessages("expressionWasFalse") else failureMessage)
      }
    }

    /**
     * Require that all of the passed in elements are not <code>null</code>, else fail with <code>NullPointerException</code>.
     *
     * @param variableNames names of variable passed as appear in source
     * @param elements elements to check for <code>null</code> value
     */
    def macroRequireNonNull(variableNames: Array[String], elements: Array[Any]) {
      val nullList = elements.zipWithIndex.filter { case (e, idx) =>
        e == null
      }
      val nullCount = nullList.size
      if (nullCount > 0) {
        val nullVariableNames = nullList.map { case (e, idx) =>
          variableNames(idx)
        }
        val errorMessage =
          if (nullCount == 1)
            FailureMessages("wasNull", UnquotedString(nullVariableNames(0)))
          else if (nullCount == 2) {
            val combinedVariableNames = Resources("and", nullVariableNames.head, nullVariableNames.last)
            FailureMessages("wereNull", UnquotedString(combinedVariableNames))
          }
          else {
            val combinedVariableNames = Resources("commaAnd", nullVariableNames.dropRight(1).mkString(Resources("comma")), nullVariableNames.last)
            FailureMessages("wereNull", UnquotedString(combinedVariableNames))
          }
        throw new NullPointerException(errorMessage)
      }
    }

  }

  /**
   * Helper instance used by code generated by macro assertion.
   */
  val requirementsHelper = new RequirementsHelper

  /**
   * Require that a boolean condition is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalArgumentException</code>.
   *
   * <p>
   * This method is implemented in terms of a Scala macro that will generate a more helpful error message
   * for simple quality checks of this form:
   * </p>
   *
   * <ul>
   * <li>require(a == b)</li>
   * <li>require(a != b)</li>
   * <li>require(a === b)</li>
   * <li>require(a !== b)</li>
   * </ul>
   *
   * <p>
   * Any other form of expression will just get a plain-old <code>IllegalArgumentException</code> at this time. In the future,
   * we will enhance this macro to give helpful error messages in more situations. In ScalaTest 2.x, however, this behavior
   * was sufficient to allow the <code>===</code> that returns <code>Boolean</code>, not <code>Option[String]</code> to be
   * the default in tests. This makes <code>===</code> consistent between tests and production code. If you have pre-existing
   * code you wrote under ScalaTest 1.x, in which you are expecting<code>===</code> to return an <code>Option[String]</code>,
   * use can get that behavior back by mixing in trait <a href="LegacyTripleEquals.html"><code>LegacyTripleEquals</code></a>.
   * </p>
   *
   * @param condition the boolean condition to check as requirement
   * @throws IllegalArgumentException if the condition is <code>false</code>.
   */
  def require(condition: Boolean): Unit = macro RequirementsMacro.require

  /**
   * Require that a boolean condition, described in <code>String</code>
   * <code>message</code>, is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalArgumentException</code> with the
   * <code>String</code> obtained by invoking <code>toString</code> on the
   * specified <code>clue</code> as the exception's detail message.
   *
   * @param condition the boolean condition to check as requirement
   * @param clue An objects whose <code>toString</code> method returns a message to include in a failure report.
   * @throws IllegalArgumentException if the condition is <code>false</code>.
   * @throws NullPointerException if <code>message</code> is <code>null</code>.
   */
  def require(condition: Boolean, clue: Any): Unit = macro RequirementsMacro.requireWithClue

  /**
   * Require that a boolean condition is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalStateException</code>.
   *
   * <p>
   * This method is implemented in terms of a Scala macro that will generate a more helpful error message
   * for simple quality checks of this form:
   * </p>
   *
   * <ul>
   * <li>requireState(a == b)</li>
   * <li>requireState(a != b)</li>
   * <li>requireState(a === b)</li>
   * <li>requireState(a !== b)</li>
   * </ul>
   *
   * <p>
   * Any other form of expression will just get a plain-old <code>IllegalStateException</code> at this time. In the future,
   * we will enhance this macro to give helpful error messages in more situations. In ScalaTest 2.x, however, this behavior
   * was sufficient to allow the <code>===</code> that returns <code>Boolean</code>, not <code>Option[String]</code> to be
   * the default in tests. This makes <code>===</code> consistent between tests and production code. If you have pre-existing
   * code you wrote under ScalaTest 1.x, in which you are expecting<code>===</code> to return an <code>Option[String]</code>,
   * use can get that behavior back by mixing in trait <a href="LegacyTripleEquals.html"><code>LegacyTripleEquals</code></a>.
   * </p>
   *
   * @param condition the boolean condition to check as requirement
   * @throws IllegalStateException if the condition is <code>false</code>.
   */
  def requireState(condition: Boolean): Unit = macro RequirementsMacro.requireState

  /**
   * Require that a boolean condition, described in <code>String</code>
   * <code>message</code>, is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalStateException</code> with the
   * <code>String</code> obtained by invoking <code>toString</code> on the
   * specified <code>clue</code> as the exception's detail message.
   *
   * @param condition the boolean condition to check as requirement
   * @param clue An objects whose <code>toString</code> method returns a message to include in a failure report.
   * @throws IllegalStateException if the condition is <code>false</code>.
   * @throws NullPointerException if <code>message</code> is <code>null</code>.
   */
  def requireState(condition: Boolean, clue: Any): Unit = macro RequirementsMacro.requireStateWithClue

  /**
   * Require that all passed in elements to be non-null.
   * If none of the passed in elements is <code>null</code>, this method returns normally.
   * Else, it throws <code>NullPointerException</code> with error message that includes the name(s)
   * (as appeared in source) of the element(s) that holds <code>null</code> value.
   *
   * @param headElement the first mandatory element to check for non-null
   * @param tailElements the rest of elements to check for non-null, optional
   * @throws NullPointerException if any of the passed in elements is <code>null</code>.
   */
  def requireNonNull(headElement: Any, tailElements: Any*): Unit = macro RequirementsMacro.requireNonNull
}

/**
 * Macro implementation that provides rich error message for boolean expression requirements.
 */
private[scalautils] object RequirementsMacro {

  /**
   * Provides requirement implementation for <code>Requirements.require(booleanExpr: Boolean)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalArgumentException</code> with rich error message if requirement failed
   */
  def require(context: Context)(condition: context.Expr[Boolean]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacro(condition, "macroRequire", context.literal(""))

  /**
   * Provides requirement implementation for <code>Requirements.require(booleanExpr: Boolean, clue: Any)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @param clue original clue expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalArgumentException</code> with rich error message (clue included) if requirement failed
   */
  def requireWithClue(context: Context)(condition: context.Expr[Boolean], clue: context.Expr[Any]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacro(condition, "macroRequire", clue)

  /**
   * Provides requirement implementation for <code>Requirements.requireState(booleanExpr: Boolean)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalStateException</code> with rich error message if requirement failed
   */
  def requireState(context: Context)(condition: context.Expr[Boolean]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacro(condition, "macroRequireState", context.literal(""))

  /**
   * Provides requirement implementation for <code>Requirements.requireState(booleanExpr: Boolean, clue: Any)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @param clue original clue expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalStateException</code> with rich error message (clue included) if requirement failed
   */
  def requireStateWithClue(context: Context)(condition: context.Expr[Boolean], clue: context.Expr[Any]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacro(condition, "macroRequireState", clue)

  /**
   * Provides requirement implementation for <code>Requirements.requireNonNull(headElement, tailElements: Any*)</code>, with rich error message.
   *
   * @param context macro context
   * @param headElement the first mandatory element to check for non-null
   * @param tailElements the rest of elements to check for non-null, optional
   * @return transformed expression that performs the requirement check and throw <code>NullPointerException</code> with rich error message if requirement failed
   */
  def requireNonNull(context: Context)(headElement: context.Expr[Any], tailElements: context.Expr[Any]*): context.Expr[Unit] = {
    import context.universe._

    val elements = headElement :: tailElements.toList
    val sourceList = new MacroSourceHelper[context.type](context).getSourceList(elements: _*)

    val variablesNamesArray =
      Apply(
        Select(
          Ident("Array"),
          newTermName("apply")
        ),
        sourceList.map(s => context.literal(s).tree)
      )

    val elementsArray =
      Apply(
        Select(
          Ident("Array"),
          newTermName("apply")
        ),
        List(elements.map(e => e.tree): _*)
      )

    context.Expr(
      Apply(
        Select(
          Ident("requirementsHelper"),
          newTermName("macroRequireNonNull")
        ),
        List(variablesNamesArray, elementsArray)
      )
    )
  }
}

/**
 * Companion object that facilitates the importing of <code>Requirements</code> members as
 * an alternative to mixing it in. One use case is to import <code>Requirements</code> members so you can use
 * them in the Scala interpreter:
 *
 * <pre class="stREPL">
 * $scala -classpath scalatest.jar
 * Welcome to Scala version 2.10.3.final (Java HotSpot(TM) Client VM, Java xxxxxx).
 * Type in expressions to have them evaluated.
 * Type :help for more information.
 * &nbsp;
 * scala&gt; import org.scalautils.Requirements._
 * import org.scalautils.Requirements._
 * &nbsp;
 * scala&gt; val a = 1
 * a: Int = 1
 * &nbsp;
 * scala&gt; require(a == 2)
 * java.lang.IllegalArgumentException: 1 did not equal 2
 *      at org.scalautils.Requirements$RequirementsHelper.macroRequire(Requirements.scala:56)
 *      at .&lt;init&gt;(&lt;console&gt;:20)
 *      at .&lt;clinit&gt;(&lt;console&gt;)
 *      at .&lt;init&gt;(&lt;console&gt;:7)
 *      at .&lt;clinit&gt;(&lt;console&gt;)
 *      at $print(&lt;console&gt;)
 *      at sun.reflect.NativeMethodAccessorImpl.invoke...
 */
object Requirements extends Requirements

