/*
 * Copyright 2001-2012 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.scalautils

import reflect.macros.Context

trait Requirements {

  import language.experimental.macros

  /**
   * Helper class used by code generated by the <code>require</code> macro.
   */
  class RequirementsHelper {

    private def append(currentMessage: String, clueOpt: Option[Any]): String =
      clueOpt match {
        case Some(clue) =>
          val firstChar = clue.toString.head
          if (firstChar.isWhitespace || firstChar == '.' || firstChar == ',' || firstChar == ';')
            currentMessage + clue.toString
          else
            currentMessage + " " + clue.toString
        case None => currentMessage
      }

    def getObjectsForFailureMessage(a: Any, b: Any) =
      a match {
        case aEqualizer: org.scalautils.TripleEqualsSupport#Equalizer[_] =>
          Prettifier.getObjectsForFailureMessage(aEqualizer.leftSide, b)
        case aEqualizer: org.scalautils.TripleEqualsSupport#CheckingEqualizer[_] =>
          Prettifier.getObjectsForFailureMessage(aEqualizer.leftSide, b)
        case _ => Prettifier.getObjectsForFailureMessage(a, b)
      }

    /**
     * Require that the passed in expression is <code>true</code>, else fail with <code>IllegalArgumentException</code>.
     *
     * @param expression <code>Boolean</code> expression to check as requirement
     * @param clue optional clue to be included in <code>IllegalArgumentException</code>'s error message when the requirement failed
     */
    def macroRequire(expression: Boolean, clue: Option[Any]) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!expression)
        throw new IllegalArgumentException(if (clue.isDefined) clue.get + "" else FailureMessages("expressionWasFalse"))
    }

    /**
     * Require that the passed in expression is <code>true</code>, else fail with <code>IllegalArgumentException</code>.
     *
     * @param left the LHS of the expression
     * @param operator the operator of the expression
     * @param right the RHS of the expression
     * @param expression <code>Boolean</code> expression to check as requirement
     * @param clue optional clue to be included in <code>IllegalArgumentException</code>'s error message when requirement failed
     */
    def macroRequire(left: Any, operator: String, right: Any, expression: Boolean, clue: Option[Any]) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!expression) {
        throw operator match {
          case "==" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("didNotEqual", leftee, rightee), clue))
          case "===" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("didNotEqual", leftee, rightee), clue))
          case "!=" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("equaled", leftee, rightee), clue))
          case "!==" =>
            val (leftee, rightee) = getObjectsForFailureMessage(left, right)
            throw new IllegalArgumentException(append(FailureMessages("equaled", leftee, rightee), clue))
          /*case ">" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotGreaterThan", left, right)), clue))
          case ">=" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotGreaterThanOrEqualTo", left, right)), clue))
          case "<" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotLessThan", left, right)), clue))
          case "<=" => throw new IllegalArgumentException(append(Some(FailureMessages("wasNotLessThanOrEqualTo", left, right)), clue))*/
          case _ =>
            throw new IllegalArgumentException(if (clue.isDefined) clue.get + "" else FailureMessages("expressionWasFalse"))
        }
      }
    }

  }

  /**
   * Helper instance used by code generated by macro assertion.
   */
  val requirementsHelper = new RequirementsHelper

  /**
   * Require that a boolean condition is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalArgumentException</code>.
   *
   * <p>
   * This method is implemented in terms of a Scala macro that will generate a more helpful error message
   * for simple quality checks of this form:
   * </p>
   *
   * <ul>
   * <li>require(a == b)</li>
   * <li>require(a != b)</li>
   * <li>require(a === b)</li>
   * <li>require(a !== b)</li>
   * </ul>
   *
   * <p>
   * Any other form of expression will just get a plain-old <code>IllegalArgumentException</code> at this time. In the future,
   * we will enhance this macro to give helpful error messages in more situations. In ScalaTest 2.x, however, this behavior
   * was sufficient to allow the <code>===</code> that returns <code>Boolean</code>, not <code>Option[String]</code> to be
   * the default in tests. This makes <code>===</code> consistent between tests and production code. If you have pre-existing
   * code you wrote under ScalaTest 1.x, in which you are expecting<code>===</code> to return an <code>Option[String]</code>,
   * use can get that behavior back by mixing in trait <a href="LegacyTripleEquals.html"><code>LegacyTripleEquals</code></a>.
   * </p>
   *
   * @param condition the boolean condition to check as requirement
   * @throws IllegalArgumentException if the condition is <code>false</code>.
   */
  def require(condition: Boolean): Unit = macro RequirementsMacro.require

  /**
   * Require that a boolean condition, described in <code>String</code>
   * <code>message</code>, is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>IllegalArgumentException</code> with the
   * <code>String</code> obtained by invoking <code>toString</code> on the
   * specified <code>clue</code> as the exception's detail message.
   *
   * @param condition the boolean condition to check as requirement
   * @param clue An objects whose <code>toString</code> method returns a message to include in a failure report.
   * @throws IllegalArgumentException if the condition is <code>false</code>.
   * @throws NullPointerException if <code>message</code> is <code>null</code>.
   */
  def require(condition: Boolean, clue: Any): Unit = macro RequirementsMacro.requireWithClue
}

/**
 * Macro implementation that provides rich error message for boolean expression requirements.
 */
private[scalautils] object RequirementsMacro {

  /**
   * Provides requirement implementation for <code>Requirements.require(booleanExpr: Boolean)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalArgumentException</code> with rich error message if requirement failed
   */
  def require(context: Context)(condition: context.Expr[Boolean]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacroCode(condition, "macroRequire", None)

  /**
   * Provides requirement implementation for <code>Requirements.require(booleanExpr: Boolean, clue: Any)</code>, with rich error message.
   *
   * @param context macro context
   * @param condition original condition expression
   * @param clue original clue expression
   * @return transformed expression that performs the requirement check and throw <code>IllegalArgumentException</code> with rich error message (clue included) if requirement failed
   */
  def requireWithClue(context: Context)(condition: context.Expr[Boolean], clue: context.Expr[Any]): context.Expr[Unit] =
    new BooleanMacro[context.type](context, "requirementsHelper").genMacroCode(condition, "macroRequire", Some(clue.tree))

}