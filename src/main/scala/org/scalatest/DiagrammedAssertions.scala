/*
 * Copyright 2001-2013 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.scalatest

import org.scalactic.Prettifier
import scala.collection.mutable.ListBuffer
import collection.immutable.TreeMap

/**
 * Sub-trait of <code>Assertions</code> that override <code>assert</code> and <code>assume</code> methods to include
 * a diagram showing the values of expression in the error message when the assertion or assumption fails.
 *
 */
trait DiagrammedAssertions extends Assertions {

  import language.experimental.macros

  /**
   * Helper class used by code generated by the overriden <code>assert</code> macro.
   */
  class DiagrammedAssertionsHelper {

    // this is taken from expecty
    private[this] def fits(line: StringBuilder, str: String, anchor: Int): Boolean =
      line.slice(anchor, anchor + str.length + 1).forall(_.isWhitespace)

    // this is taken from expecty
    private[this] def placeString(line: StringBuilder, str: String, anchor: Int) {
      val diff = anchor - line.length
      for (i <- 1 to diff) line.append(' ')
      line.replace(anchor, anchor + str.length(), str)
    }

    // this is taken from expecty and modified
    private[this] def renderValue(value: Any): String = {
      value match {
        case aEqualizer: org.scalactic.TripleEqualsSupport#Equalizer[_] => Prettifier.default(aEqualizer.leftSide)
        case aEqualizer: org.scalactic.TripleEqualsSupport#CheckingEqualizer[_] => Prettifier.default(aEqualizer.leftSide)
        case _ => Prettifier.default(value)
      }
    }

    // this is taken from expecty
    private[this] def placeValue(lines: ListBuffer[StringBuilder], value: Any, col: Int) {
      val str = renderValue(value)

      placeString(lines(0), "|", col)

      for (line <- lines.drop(1)) {
        if (fits(line, str, col)) {
          placeString(line, str, col)
          return
        }
        placeString(line, "|", col)
      }

      val newLine = new StringBuilder()
      placeString(newLine, str, col)
      lines.append(newLine)
    }

    // this is taken from expecty
    private[this] def filterAndSortByAnchor(anchorValues: List[AnchorValue]): Traversable[AnchorValue] = {
      var map = TreeMap[Int, AnchorValue]()(Ordering.by(-_))
      // values stemming from compiler generated code often have the same anchor as regular values
      // and get recorded before them; let's filter them out
      for (value <- anchorValues) if (!map.contains(value.anchor)) map += (value.anchor -> value)
      map.values
    }

    // this is taken from expecty
    private[this] def renderDiagram(sourceText: String, anchorValues: List[AnchorValue]): String = {
      val offset = sourceText.prefixLength(_.isWhitespace)
      val intro = new StringBuilder().append(sourceText.trim())
      val lines = ListBuffer(new StringBuilder)

      val rightToLeft = filterAndSortByAnchor(anchorValues)
      for (anchorValue <- rightToLeft) placeValue(lines, anchorValue.value, anchorValue.anchor - offset)

      lines.prepend(intro)
      lines.append(new StringBuilder)
      lines.mkString("\n")
    }

    /**
     * Assert that the passed in <code>Bool</code> is <code>true</code>, else fail with <code>TestFailedException</code>
     * with error message that include a diagram showing expression values.
     *
     * @param bool the <code>Bool</code> to assert for
     * @param clue optional clue to be included in <code>TestFailedException</code>'s error message when assertion failed
     */
    def macroAssert(bool: DiagrammedExpr[Boolean], clue: Any, sourceText: String) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!bool.value) {
        val failureMessage =
          Some(clue + "\n\n" + renderDiagram(sourceText, bool.anchorValues))
        throw newAssertionFailedException(failureMessage, None, "Assertions.scala", "macroAssert", 2)
      }
    }

    /**
     * Assume that the passed in <code>Bool</code> is <code>true</code>, else throw <code>TestCanceledException</code>
     * with error message that include a diagram showing expression values.
     *
     * @param bool the <code>Bool</code> to assume for
     * @param clue optional clue to be included in <code>TestCanceledException</code>'s error message when assertion failed
     */
    def macroAssume(bool: DiagrammedExpr[Boolean], clue: Any, sourceText: String) {
      if (clue == null)
        throw new NullPointerException("clue was null")
      if (!bool.value) {
        val failureMessage =
          Some(clue + "\n\n" + renderDiagram(sourceText, bool.anchorValues))
        throw newTestCanceledException(failureMessage, None, "Assertions.scala", "macroAssume", 2)
      }
    }
  }

  /**
   * Helper instance used by code generated by the overriden macro assertion.
   */
  val diagrammedAssertionsHelper = new DiagrammedAssertionsHelper

  /**
   * Assert that a boolean condition is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>TestFailedException</code>.
   *
   * <p>
   * This method is implemented in terms of a Scala macro that will generate a more helpful error message that includes
   * a diagram showing expression values.
   * </p>
   *
   * <p>
   * If multi-line <code>Boolean</code> is passed in, it will fallback to the macro implementation of <code>Assertions</code>
   * that does not contain diagram.
   * </p>
   *
   * @param condition the boolean condition to assert
   * @throws TestFailedException if the condition is <code>false</code>.
   */
  override def assert(condition: Boolean): Unit = macro DiagrammedAssertionsMacro.assert

  /**
   * Assert that a boolean condition, described in <code>String</code>
   * <code>message</code>, is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>TestFailedException</code> with the
   * <code>String</code> obtained by invoking <code>toString</code> on the
   * specified <code>clue</code> as the exception's detail message and a
   * diagram showing expression values.
   *
   * <p>
   * If multi-line <code>Boolean</code> is passed in, it will fallback to the macro implementation of <code>Assertions</code>
   * that does not contain diagram.
   * </p>
   *
   * @param condition the boolean condition to assert
   * @param clue An objects whose <code>toString</code> method returns a message to include in a failure report.
   * @throws TestFailedException if the condition is <code>false</code>.
   * @throws NullPointerException if <code>message</code> is <code>null</code>.
   */
  override def assert(condition: Boolean, clue: Any): Unit = macro DiagrammedAssertionsMacro.assertWithClue

  /**
   * Assume that a boolean condition is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>TestCanceledException</code>.
   *
   * <p>
   * This method is implemented in terms of a Scala macro that will generate a more helpful error message that includes
   * a diagram showing expression values.
   * </p>
   *
   * <p>
   * If multi-line <code>Boolean</code> is passed in, it will fallback to the macro implementation of <code>Assertions</code>
   * that does not contain diagram.
   * </p>
   *
   * @param condition the boolean condition to assume
   * @throws TestCanceledException if the condition is <code>false</code>.
   */
  override def assume(condition: Boolean): Unit = macro DiagrammedAssertionsMacro.assume

  /**
   * Assume that a boolean condition, described in <code>String</code>
   * <code>message</code>, is true.
   * If the condition is <code>true</code>, this method returns normally.
   * Else, it throws <code>TestCanceledException</code> with the
   * <code>String</code> obtained by invoking <code>toString</code> on the
   * specified <code>clue</code> as the exception's detail message and a
   * diagram showing expression values.
   *
   * <p>
   * If multi-line <code>Boolean</code> is passed in, it will fallback to the macro implementation of <code>Assertions</code>
   * that does not contain diagram.
   * </p>
   *
   * @param condition the boolean condition to assume
   * @param clue An objects whose <code>toString</code> method returns a message to include in a failure report.
   * @throws TestCanceledException if the condition is <code>false</code>.
   * @throws NullPointerException if <code>message</code> is <code>null</code>.
   */
  override def assume(condition: Boolean, clue: Any): Unit = macro DiagrammedAssertionsMacro.assumeWithClue
}

/**
 * Companion object that facilitates the importing of <code>DiagrammedAssertions</code> members as
 * an alternative to mixing it in. One use case is to import <code>DiagrammedAssertions</code> members so you can use
 * them in the Scala interpreter:
 *
 * <pre class="stREPL">
 * $scala -classpath scalatest.jar
 * Welcome to Scala version 2.10.4.final (Java HotSpot(TM) Client VM, Java 1.6.0_45).
 * Type in expressions to have them evaluated.
 * Type :help for more information.
 * &nbsp;
 * scala&gt; import org.scalatest.Assertions._
 * import org.scalatest.Assertions._
 * &nbsp;
 * scala&gt; assert(1 === 2)
 * org.scalatest.exceptions.TestFailedException:
 *
 * assert(1 === 2)
 *        | |   |
 *        1 |   2
 *          false
 *
 *      at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:422)
 * 	    at org.scalatest.DiagrammedAssertions$.newAssertionFailedException(DiagrammedAssertions.scala:249)
 * 	    at org.scalatest.DiagrammedAssertions$DiagrammedAssertionsHelper.macroAssert(DiagrammedAssertions.scala:111)
 * 	    at .&lt;init&gt;(&lt;console&gt;:20)
 * 	    at .&lt;clinit&gt;(&lt;console&gt;)
 * 	    at .&lt;init&gt;(&lt;console&gt;:7)
 * 	    at .&lt;clinit&gt;(&lt;console&gt;)
 *  	  at $print(&lt;console&gt;)
 * 	    at sun.reflect.NativeMethodAccessorImpl.invoke...
 * </pre>
 */
object DiagrammedAssertions extends DiagrammedAssertions